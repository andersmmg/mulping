#!/bin/env python3

import os
import sys
import json
import argparse
import subprocess

from time import time

RELAYS_LINK = "https://api.mullvad.net/www/relays/all/"
RELAYS_FILE = "/tmp/mulpingData"

TIMESTAMP_INDEX = 0

HOSTNAME = "hostname"
TYPE = "type"
ACTIVE = "active"
COUNTRY_CODE = "country_code"
CITY_CODE = "city_code"
IPV4 = "ipv4_addr_in"
IPV6 = "ipv6_addr_in"
PROVIDER = "provider"
BANDWIDTH = "network_port_speed"
OWNED = "owned"
STBOOT = "stboot"

WIREGUARD = "wireguard"
OPENVPN = "openvpn"
BRIDGE = "bridge"


#############################
# Relay filtering utilities #
#############################


# Returns a function that returns a function that tests
# if attribute 'a' in relay 'r' has value 'v'
eqAttr = lambda a: (lambda v: (lambda r: a in r and r[a] == v))

# Analogous
neqAttr = lambda a: (lambda v: (lambda r: a in r and r[a] != v))
geqAttr = lambda a: (lambda v: (lambda r: a in r and r[a] >= v))

# Returns a function that given a relay 'r', tests if it fits at least one of the conditions in 'filters'
filterOr = lambda filters: (lambda r: [f(r) for f in filters].count(True) > 0)

# Returns a function that given a relay 'r', tests if it fits all of the conditions in 'filters'
filterAnd = lambda filters: (lambda r: [f(r) for f in filters].count(False) == 0)


##################
# Error handling #
##################


def perror(err):
    print(err, file = sys.stderr)

def failure(err):
    perror(err)
    sys.exit(1)


#########################
# Relays data retrieval #
#########################


def fetchRelays():
    print("Fetching relays... ", end = "")
    sys.stdout.flush()

    # Only import the "requests" module here as it takes
    # significantly longer than the others
    import requests

    try:
        relays = requests.get(f"{RELAYS_LINK}").json()
    except:
        failure("Could not get relays")

    relays.insert(TIMESTAMP_INDEX, time())
    with open(RELAYS_FILE, "w") as f:
        json.dump(relays, f)
    del relays[TIMESTAMP_INDEX]

    print("done!\n")
    return relays

def loadRelays():
    with open(RELAYS_FILE, "r") as f:
        relays = json.loads(f.read())

    if not isinstance(relays[TIMESTAMP_INDEX], (float, int)):
        raise Exception

    # If the data is more than 12 hours old, fetch it again
    if time() - relays[TIMESTAMP_INDEX] >= 43200:
        raise Exception

    # Delete timestamp from final relay list
    del relays[TIMESTAMP_INDEX]

    return relays

def getRelays():
    if os.path.isfile(RELAYS_FILE):
        try:
            relays = loadRelays()
        except:
            relays = fetchRelays()
    else:
        relays = fetchRelays()

    return relays


##################
# Ping utilities #
##################


def parsePing(pingOutput):
    resultsLine = pingOutput.splitlines()[pingOutput.count("\n") - 1]

    if not resultsLine.startswith("rtt"):
        return None, None, None

    rtts = [float(v) for v in resultsLine.split(" ")[3].split("/")]

    return rtts[0], rtts[1], rtts[2]

def ping(addr, count, timeout = 0, ipv6 = False):
    try:
        # e.g.: ping 0.0.0.0 -nqc1 -W0
        pingCommand = ["ping", addr, "-nqc", str(count), "-W", str(timeout)]
        if ipv6: pingCommand.append("-6")

        pingProcess = subprocess.run(pingCommand, capture_output = True)
    except:
        failure("The `ping` program could not be called")

    if pingProcess.returncode != 0:
        return None, None, None

    return parsePing(pingProcess.stdout.decode())


#####################
# Mullvad utilities #
#####################


def mullvadChangeRelay(hostname):
    try:
        mullvadProcess = subprocess.run(["mullvad", "relay", "set", "hostname", hostname])

        if mullvadProcess.returncode != 0:
            raise Exception
    except:
        failure(f"An error occurred while trying to change the Mullvad relay options to hostname {hostname}")


######################
# Printing utilities #
######################

SPACES_HOSTNAME = 15
SPACES_IPV4 = 16
SPACES_COUNTRY_CODE = 2
SPACES_CITY_CODE = 3
SPACES_PROVIDER = 10
SPACES_PING = 10

ITEMS_SHORT_SPACES = [
    SPACES_HOSTNAME,
    SPACES_PING
]

ITEMS_LONG_SPACES = [
    SPACES_HOSTNAME,
    SPACES_COUNTRY_CODE,
    SPACES_CITY_CODE,
    SPACES_PROVIDER,
    SPACES_IPV4,
    SPACES_PING
]

shortResults = [HOSTNAME]
longResults = [HOSTNAME, COUNTRY_CODE, CITY_CODE, PROVIDER, IPV4]

formatRtt = lambda rtt: f"{rtt:.3f}ms"

def printBox(items, start, end, middle, regular):
    if items == []: return ""

    box = start
    for i in items:
        box += regular * (i + 2) + middle

    box = box[0:len(box) - 1] + end
    
    print(box)

def printResult(relay, rtt, attributes, spaces, wall):
    if len(attributes) + 1 != len(spaces):
        failure("Malformed data received by printing function")

    print(f"{wall} ", end = "")
    for attribute, spacing in zip(attributes, spaces[0:len(spaces) - 1]):
        print(f"{relay[attribute]:{spacing}} {wall} ", end = "")

    rttFormatted = formatRtt(rtt) if isinstance(rtt, float) else "error"
    print(f"{rttFormatted:{spaces[len(spaces) - 1]}} {wall}")


########
# Main #
########


parser = argparse.ArgumentParser(
    prog = "mulping",
    description = "Batch pings utility for Mullvad VPN (not affiliated)",
)

relayConditions = [
    neqAttr(TYPE)(BRIDGE),
    eqAttr(ACTIVE)(True)
]

parser.add_argument("-c", "--country", action = "store", help = "Only select servers located in the countries specified", nargs = "+", metavar = "country_code")
parser.add_argument("-cn", "--country-not", action = "store", help = "Exclude servers located in the countries specified", nargs = "+", metavar = "country_code")
parser.add_argument("-C", "--city", action = "store", help = "Only select servers located in the cities specified", nargs = "+", metavar = "city_code")
parser.add_argument("-Cn", "--city-not", action = "store", help = "Exclude servers located in the cities specified", nargs = "+", metavar = "city_code")
parser.add_argument("-p", "--provider", action = "store", help = "Only select servers using the specified providers", nargs = "+", metavar = "provider")
parser.add_argument("-pn", "--provider-not", action = "store", help = "Exclude servers using the specified providers", nargs = "+", metavar = "provider")
parser.add_argument("-w", "--wireguard", action = "store_true", help = "Only select WireGuard servers")
parser.add_argument("-o", "--openvpn", action = "store_true", help = "Only select OpenVPN servers")
parser.add_argument("-s", "--stboot", action = "store_true", help = "Only select stboot servers")
parser.add_argument("-O", "--owned", action = "store_true", help = "Only select servers owned by Mullvad")
parser.add_argument("-b", "--bandwidth", action = "store", help = "Only select servers that have at least this bandwidth speed (Gbps)", metavar = "bandwidth")
parser.add_argument("-t", "--timeout", action = "store", help = "Maximum time to wait for each ping response", metavar = "timeout")
parser.add_argument("-6", "--ipv6", action = "store_true", help = "Use IPv6 to ping servers (requires IPv6 connectivity on both ends)")
parser.add_argument("-u", "--use", action = "store_true", help = "Change Mullvad relay options to use the lowest latency server tested")

args = parser.parse_args()

if args.country != None:
	countryConditions = list(map(eqAttr(COUNTRY_CODE), args.country))

	countryFilter = filterOr(countryConditions)	
	relayConditions.append(countryFilter)

if args.country_not != None:
	notCountryConditions = list(map(neqAttr(COUNTRY_CODE), args.country_not))

	notCountryFilter = filterAnd(notCountryConditions)	
	relayConditions.append(notCountryFilter)

if args.city != None:
    cities = list(zip(args.city[::2], args.city[1::2]))
    
    # Returns a function that tests if relay 'r' is in the city defined by the tuple 'cityTuple'
    # cityTuple[0] -> country code
    # cityTuple[1] -> city code
    inCity = lambda cityTuple: (lambda r: eqAttr(COUNTRY_CODE)(cityTuple[0])(r) and eqAttr(CITY_CODE)(cityTuple[1])(r))

    cityConditions = list(map(inCity, cities))

    cityFilter = filterOr(cityConditions)
    relayConditions.append(cityFilter)

if args.city_not != None:
    notCities = list(zip(args.city_not[::2], args.city_not[1::2]))

    # Symmetrical to inCity
    notInCity = lambda cityTuple: (lambda r: not (eqAttr(COUNTRY_CODE)(cityTuple[0])(r) and eqAttr(CITY_CODE)(cityTuple[1])(r)))

    notCityConditions = list(map(notInCity, notCities))

    notCityFilter = filterAnd(notCityConditions)
    relayConditions.append(notCityFilter)

if args.provider != None:
	providerConditions = list(map(eqAttr(PROVIDER), args.provider))

	providerFilter = filterOr(providerConditions)	
	relayConditions.append(providerFilter)

if args.provider_not != None:
	notProviderConditions = list(map(neqAttr(PROVIDER), args.provider_not))

	notProviderFilter = filterAnd(notProviderConditions)	
	relayConditions.append(notProviderFilter)

if args.bandwidth:
  try:
    relayConditions.append(geqAttr(BANDWIDTH)(float(args.bandwidth)))
  except:
    failure("Error: the bandwidth option must be a number")

if args.wireguard: relayConditions.append(eqAttr(TYPE)(WIREGUARD))
if args.openvpn: relayConditions.append(eqAttr(TYPE)(OPENVPN))
if args.stboot: relayConditions.append(eqAttr(STBOOT)(True))
if args.owned: relayConditions.append(eqAttr(OWNED)(True))

timeout = 10 if args.timeout == None else float(args.timeout) / 1000

relays = list(filter(filterAnd(relayConditions), getRelays()))

if relays == []:
    failure("The conditions specified resulted in no relays")

latencies = []
printBox(ITEMS_SHORT_SPACES, "┌", "┐", "┬", "─")
for r in relays:
    host = r[HOSTNAME]
    address = r[IPV4]

    if args.ipv6:
        if IPV6 in r: address = r[IPV6]
        else:
            printResult(r, None, "│")
            continue

    _, rtt, _ = ping(address, 1, timeout = timeout, ipv6 = args.ipv6)

    printResult(r, rtt, shortResults, ITEMS_SHORT_SPACES, "│")

    if rtt != None: latencies.append((host, rtt))
printBox(ITEMS_SHORT_SPACES, "└", "┘", "┴", "─")

if latencies == []:
    failure("\nNo relay could be reached")

lowestLatency = min(latencies, key = lambda e: e[1])
maxLatency = max(latencies, key = lambda e: e[1])

print(f"\nHighest latency host: {maxLatency[0]} ({maxLatency[1]}ms)")
print(f"Lowest latency host: {lowestLatency[0]} ({lowestLatency[1]}ms)")

if args.use:
    print()
    mullvadChangeRelay(lowestLatency[0])
