#!/bin/env python3

import requests
import sys
import argparse
import subprocess

RELAYS_LINK = "https://api.mullvad.net/www/relays/all/"

HOSTNAME = "hostname"
TYPE = "type"
ACTIVE = "active"
COUNTRY_CODE = "country_code"
IPV4 = "ipv4_addr_in"

WIREGUARD = "wireguard"
OPENVPN = "openvpn"
BRIDGE = "bridge"

# Returns a function that tests if attribute 't' has value 'v' in relay 'r'
eqAttribute = lambda a, v: (lambda r: a in r and r[a] == v)

# Returns a function that tests if a relay is of type 't'
isType = lambda t: eqAttribute(TYPE, t)

# Returns a function that tests if a relay has country code 'c'
inCountry = lambda c: eqAttribute(COUNTRY_CODE, c)

# Tests if a relay 'r' is not a bridge
notBridge = lambda r: not isType(BRIDGE)(r)

# Returns a function that given a relay 'r', tests if it fits at least one of the conditions in 'filters'
filterOr = lambda filters: (lambda r: [f(r) for f in filters].count(True) > 0)

# Returns a function that given a relay 'r', tests if it fits all of the conditions in 'filters'
filterAnd = lambda filters: (lambda r: [f(r) for f in filters].count(False) == 0)

def perror(err):
    print(err, file = sys.stderr)

def failure(err):
    perror(err)
    sys.exit(1)

def getRelays():
    try:
        relays = requests.get(f"{RELAYS_LINK}").json()
    except:
        failure("Could not get relays")

    return relays

def parsePing(pingOutput):
    resultsLine = pingOutput.splitlines()[pingOutput.count("\n") - 1]

    if not resultsLine.startswith("rtt"):
        return None, None, None

    rtts = [float(v) for v in resultsLine.split(" ")[3].split("/")]

    return rtts[0], rtts[1], rtts[2]

def ping(addr, count, timeout = 0):
    try:
        # e.g.: ping 0.0.0.0 -nqc1 -W0
        pingProcess = subprocess.run(["ping", addr, "-nqc", str(count), "-W", str(timeout)], capture_output = True)
    except:
        failure("The `ping` program could not be called")

    if pingProcess.returncode != 0:
        return None, None, None

    return parsePing(pingProcess.stdout.decode())

parser = argparse.ArgumentParser(
    prog = "mulping",
    description = "Batch pings utility for Mullvad VPN (not affiliated)",
)

relayConditions = [notBridge]

parser.add_argument("-c", "--country", action = "store", help = "Filter by country", nargs = "+", required = False)
parser.add_argument("-w", "--wireguard", action = "store_true", help = "Only select WireGuard servers")
parser.add_argument("-o", "--openvpn", action = "store_true", help = "Only select OpenVPN servers")
parser.add_argument("-t", "--timeout", action = "store", help = "Maximum time to wait for each` ping response")

args = parser.parse_args()

if args.country != None:
	countryConditions = list(map(inCountry, args.country))

	countryFilter = filterOr(countryConditions)	
	relayConditions.append(countryFilter)

if args.wireguard: relayConditions.append(isType(WIREGUARD))
if args.openvpn: relayConditions.append(isType(OPENVPN))

timeout = 0 if args.timeout == None else float(args.timeout)

relays = filter(filterAnd(relayConditions), getRelays())

if relays == []:
    failure("The conditions specified resulted in no relays")

latencies = []
for r in relays:
    host = r[HOSTNAME]
    address = r[IPV4]

    if not r[ACTIVE]:
        print(f"{host:15} -> inactive")
        continue

    _, rtt, _ = ping(address, 1, timeout = timeout)
    if rtt == None:
        perror(f"{host:15} -> error")
        continue

    print(f"{host:15} -> {rtt:.3f}ms")

    latencies.append((host, rtt))

if latencies == []:
    failure("No relay could be reached")

lowestLatency = min(latencies, key = lambda e: e[1])
maxLatency = max(latencies, key = lambda e: e[1])

print(f"\nHighest latency host: {maxLatency[0]} ({maxLatency[1]}ms)")
print(f"Lowest latency host: {lowestLatency[0]} ({lowestLatency[1]}ms)")
